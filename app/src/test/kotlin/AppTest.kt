/*
 * This source file was generated by the Gradle 'init' task
 */

import ai.djl.Application
import ai.djl.repository.zoo.ModelZoo
import plugins.newpipe.OkHttpDownloader
import plugins.M3uUrlHandler
import plugins.RssUrlHandler
import capabilities.attemptUntilOneSucceeds
import capabilities.resolveUrlToString
import kotlinx.serialization.json.Json
import org.schabi.newpipe.extractor.NewPipe
import org.schabi.newpipe.extractor.ServiceList
import org.schabi.newpipe.extractor.search.SearchInfo
import plugins.newpipe.*
import java.io.File
import java.io.FileOutputStream
import java.io.InputStream
import java.io.PrintStream
import kotlin.test.Test
import kotlin.test.assertTrue

fun withStreams(
    out : PrintStream = System.out ,
    err : PrintStream = System.err ,
    input : InputStream = System.`in` ,
    func : ()->Unit
) {

    val stdOut = System.out ; val stdErr = System.err ; val stdIn = System.`in`
    System.setOut(out) ; System.setErr(err) ; System.setIn(input)
    func()
    System.setOut(stdOut) ; System.setErr(stdErr) ; System.setIn(stdIn)
}

fun testMain(vararg args : String , testName : String) {
    File("test_results").mkdirs()
    withStreams (out = PrintStream(FileOutputStream("test_results/$testName")) ) {
        main(args.map{it}.toTypedArray())
    }
}

class AppTest {

    @Test fun testCLISearchPodcastIndex() = testMain("search","podcastindex","linux" , testName = "podcastindex_search.json")
    @Test fun testCLISearchYoutube() = testMain("search","youtube","linux" , testName = "youtube_search.json")
    @Test fun testCLISearchSoundCloud() = testMain("search","soundcloud","linux", testName = "soundcloud_search.json")
    @Test fun testCLISearchPeerTube() = testMain("search","peertube","linux", testName = "peertube_search.json")
//    @Test fun testCLISearchMediaCCC() = testMain("search","mediaccc","linux", testName = "mediaccc_search.json")
    @Test fun testCLISearchBandCamp() = testMain("search","bandcamp","linux", testName = "bandcamp_search.json")
    @Test fun testCLIStreamYoutube() = testMain("stream","https://www.youtube.com/watch?v=bB9z2HEldNw" , testName = "youtube_stream.json")
    @Test fun testCLIChannelYoutube() = testMain("channel","https://www.youtube.com/@TheLinuxEXP" , testName = "youtube_channel.json")
    @Test fun testCLIPlaylistYoutube() = testMain("playlist" , "https://www.youtube.com/playlist?list=PLqmbcbI8U55EQLnXs1ehDw5-D94vloCzb" , testName = "youtube_playlist.json")
    @Test fun testCLIM3uUrlHandling() = testMain("playlist","https://raw.githubusercontent.com/Free-TV/IPTV/master/playlist.m3u8" , testName = "m3u_url_handling.json")
    @Test fun testCLIRssUrlHandling() = testMain("playlist","https://runtube.re/feeds/videos.xml?videoChannelId=34652" , testName = "rss_url_handling.json")

    @Test fun embeddingQuickSanityCheck() {
        val v = transformSentence("Mars is the red planet")
        println(v!!.size)           // should be 768
        println(v.map{it*it}.sum()) // should be ~1.0
    }

    @Test fun testSearchNextPageDeserialization() {
        NewPipe.init(OkHttpDownloader())
        NextPage.fromJson(
            NextPage.SearchNextPage(
                "youtube",
                "linux",
                listOf("all"),
                "",
                SearchInfo.getInfo(
                    ServiceList.YouTube ,
                    ServiceList.YouTube.searchQHFactory.fromQuery("linux")
                ).nextPage
            ).toJson()
        ).items.items.take(3).let {
            println(Json.encodeToString(it))
        }
    }

    private fun cosineSimilarity(a: FloatArray, b: FloatArray): Float {
        require(a.size == b.size)

        var dot = 0.0
        var normA = 0.0
        var normB = 0.0

        for (i in a.indices) {
            dot += a[i] * b[i]
            normA += a[i] * a[i]
            normB += b[i] * b[i]
        }

        return (dot / (Math.sqrt(normA) * Math.sqrt(normB))).toFloat()
    }

    @Test
    fun `similar sentences are closer than unrelated ones`() {
        val s1 = "The cat is sitting on the sofa"
        val s2 = "A kitty is lying on a couch"
        val s3 = "Quantum mechanics describes subatomic particles"

        val e1 = transformSentence(s1)!!
        val e2 = transformSentence(s2)!!
        val e3 = transformSentence(s3)!!

        val sim12 = cosineSimilarity(e1, e2)
        val sim13 = cosineSimilarity(e1, e3)

        println("Similarity(s1, s2) = ${cosineSimilarity(e1, e2)}")
        println("Similarity(s1, s3) = ${cosineSimilarity(e1, e3)}")
        println("Similarity(s2, s3) = ${cosineSimilarity(e2, e3)}")

        assertTrue(
            sim12 > sim13,
            "Related sentences should be more similar than unrelated ones"
        )

        // Optional but useful threshold
        assertTrue(
            sim12 > 0.5f,
            "Expected reasonably high similarity for paraphrases"
        )
    }
    /*@Test fun testCLI() {
        testCLISearchYoutube()
        testCLISearchSoundCloud()
        testCLISearchPeerTube()
        testCLISearchMediaCCC()
        testCLISearchBandCamp()
        testCLIStreamYoutube()
        testCLIChannelYoutube()
        testCLIPlaylistYoutube()
    }*/

    fun red(str: String) = "\u001B[31m$str\u001B[0m"
    fun yellow(str: String) = "\u001B[93m$str\u001B[0m"
    fun green(str: String) = "\u001B[92m$str\u001B[0m"

    fun error(message : String) = println(red("Error: ") + message)
    fun warning(message : String) = println(yellow("Warning: ") + message)
    fun good(message : String) = println(green("Good: ") + message)

    fun Backend.testSearch() {
        searchProviders.forEach {
            try {
                it.search("linux").let { results ->
                    if(results.items.items.isEmpty()) warning("service ${it.name} search returned empty list")
                    else good("service ${it.name} search returned some results")
                    backend.moreItemsProvider.attemptUntilOneSucceeds { provider ->
                        results.items.nextPageToken?.let { token ->
                            provider.moreItems(token)?.let{ good("Next page token is fine") }?:error("Next page token is not fine")
                        } ?: warning("Next page for search of ${it.name} is null")
                    } ?: error("Unable to get to next page for service: ${it.name}")
                }
            } catch (e:Exception) {
                error("${it.name} search threw exception: ${e.stackTraceToString()}")
                null
            }
        }
    }

    @Test fun testBackendSearch() = backend.testSearch()

    @Test fun testPodcastIndexBasicSearch() {
        podcastindex.lists.search(podcastindex.name,"christ").let { results ->
            results.items.forEach { item ->
                println("${item.name}")
            }
            println("Next Page: ${results.nextPageToken}")
        }
    }

    @Test fun testRssUrlHandler() {
        RssUrlHandler.infoProviders[0].playlist("https://www.spreaker.com/show/6003534/episodes/feed").let {
            println("Name: ${it.name}")
            println("Description: ${it.description?.content}")
            println("Number of Episodes: ${it.items?.detailedItems?.size?:0} ")
        }
    }

    @Test fun testDownloadToString() {
        println(resolveUrlToString("https://raw.githubusercontent.com/Free-TV/IPTV/master/playlist.m3u8").length)
    }

    @Test fun testM3uUrlHandler() {
        M3uUrlHandler.infoProviders[0].playlist("https://raw.githubusercontent.com/Free-TV/IPTV/master/playlist.m3u8") .let {
            println("URL: ${it.url}")
            println("Number of items: ${it.items?.items?.size?:0} ")
        }
    }

    fun printTextEmbeddingModelsInZoo() {
        ModelZoo.listModels()[Application.NLP.TEXT_EMBEDDING]?.let { models ->
            println("number of text embedding models models: ${models.size}")
            models.forEach { model ->
                println(model)
                println()
            }
        }
    }

//    fun runEmbeddingModelBenchMark() {
//        listOf(
//            ""
//        )
//    }
//
//    @Test fun scratchFile() {
//
//    }
}

